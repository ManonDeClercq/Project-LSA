---
title: "GroupProjectMarkdown"
output: html_document
date: "2024-11-21"
---
Installation and calling of packages
```{r}
install.packages("tidyverse")
install.packages("readxl")
install.packages("visdat")
install.packages("naniar")
install.packages("imputeTS")
library(readxl)
library(tidyverse)
library(visdat)
library(naniar)
library(imputeTS)
```


Reading file metadata as CSV and conversion of abundances excel to TSV
```{r}
metadata_csv_raw <- read_csv("metadata.csv")

abundances <- read_excel("abundances.xlsx", sheet = 1)
write.table(abundances, file = "abundances.tsv", sep = "\t", row.names = FALSE, quote = FALSE)
abundances_tsv_raw <- read_tsv("abundances.tsv")
```


Check class of files
```{r}
class(abundances_tsv_raw) #spec_tbl_df / tbl_df / tbl / data.frame
class(metadata_csv_raw) #spec_tbl_df / tbl_df / tbl / data.frame
```


Exploring data + checking for missing data
```{r}
summary(metadata_csv_raw) #min and max 0 means 1 value: HCV, HBV, lymphatic_metastasis, macrovascular_invasion, profiling_data_QC_status, BCLC
summary(abundances_tsv_raw)
str(metadata_csv_raw)
str(abundances_tsv_raw)


#check for missing values 
library(visdat) 
vis_miss(metadata_csv_raw) #missing values in Tumor_cellularity_(%) (0.5% missing) 
vis_miss(abundances_tsv_raw) #missing values (22.9% missing)

gg_miss_var(metadata_csv_raw)  
gg_miss_var(abundances_tsv_raw)


#count missing values in metadata
na_count <- sum(is.na(metadata_csv_raw$`Tumor_cellularity_(%)`))
na_count #there are 10 missing values out of 101 values

#check which ID's are associated with these NA's
na_indices <- which(is.na(metadata_csv_raw$`Tumor_cellularity_(%)`))
na_ids <- metadata_csv_raw$ID[na_indices]
na_ids

#effective removal of missing continued later during cleaning
```


Data cleaning + new files
```{r}
#change BCLC_(stage) to BCLC because brackets could give problems with the code
colnames(metadata_csv_raw)[colnames(metadata_csv_raw) == "BCLC_(stage)"] <- "BCLC"

#change Diameter_of_tumor_(cm) to Diameter_of_tumor because brackets could give problems with the code
colnames(metadata_csv_raw)[colnames(metadata_csv_raw) == "Diameter_of_tumor_(cm)"] <- "Diameter_of_tumor" 

#change AFP(>200_ng/ml)(cm) to AFP because brackets could give problems with the code
colnames(metadata_csv_raw)[colnames(metadata_csv_raw) == "AFP(>200_ng/ml)"] <- "AFP"

#removal of columns with only 1 value
metadata_csv_clean <- metadata_csv_raw %>% select(-HCV, -Lymphatic_metastasis, -Macrovascular_invasion, -Profiling_data_QC_status, -HBV, -BCLC)

#change gender and other 0-1's to factor: HBV, liver cirrhosis, MVI, AFP, recurr_status, survival_status, BCLC_stage
metadata_csv_clean$Gender <- as.factor(metadata_csv_clean$Gender) 
metadata_csv_clean$Liver_cirrhosis <- as.factor(metadata_csv_clean$Liver_cirrhosis) 
metadata_csv_clean$MVI <- as.factor(metadata_csv_clean$MVI) 
metadata_csv_clean$AFP <- as.factor(metadata_csv_clean$AFP) 
metadata_csv_clean$Recurr_status <- as.factor(metadata_csv_clean$Recurr_status) 
metadata_csv_clean$Survival_status <- as.factor(metadata_csv_clean$Survival_status) 

str(metadata_csv_clean) 

abundances_tsv_clean <- abundances_tsv_raw 
```


Removal of missing data from metadata
```{r}
#MCAR: little's MCAR test 
mcar_test_result <- naniar::mcar_test(metadata_csv_clean) 
print(mcar_test_result) #result suggest MCAR (p-value 0.08366846)  
#deletion because the missing data is MCAR and not a lot of missing values 

colnames(metadata_csv_clean)[colnames(metadata_csv_clean) == "Tumor_cellularity_(%)"] <- "Tumor_cellularity"

#removing NA values (missing values)
metadata_csv_clean <- metadata_csv_clean[!is.na(metadata_csv_clean$Tumor_cellularity), ]
```


Imputation in abundances data
```{r}

# Split into metadata and patient data
abundances_metadata <- abundances_tsv_raw %>% select(c("ID", "Protein.names", "Symbol"))
abundances_patient_data <- abundances_tsv_raw %>% select(-c("ID", "Protein.names", "Symbol"))

#MCAR test for abundances_patient_data
abundances_mcar_test_result <- naniar::mcar_test(abundances_patient_data) 
print(abundances_mcar_test_result) #result suggest MCAR (p-value = 1, far above 0.05)


#filter columns with too much missing data
list_filtering_metadata <- list()

for (x in 1:nrow(abundances_metadata)) {
  NA_amount_row <- sum(is.na(abundances_patient_data[x,]))
  fractionrowNA <- NA_amount_row/199
  if (fractionrowNA > 0.05) {
    list_filtering_metadata[[x]] <- 1
  } else {
    list_filtering_metadata[[x]] <- 0
  }
    
}
#check how many of the rows have more than X% data missing
table(unlist(list_filtering_metadata))
#convert list to vector, which you can use to filter the abundances 
vector_filtering_metadata <- unlist(list_filtering_metadata)

#visual check for filter in abundances
abundances_testing <- abundances_patient_data[vector_filtering_metadata==0, ]
vis_miss(abundances_testing)


# Separate healthy and tumor samples based on column names
abundances_healthy_samples <- abundances_patient_data %>% select(contains("P"))
abundances_tumor_samples <- abundances_patient_data %>% select(contains("T"))


# Function to impute missing values using mean imputation
impute_missing <- function(data) {
  data %>% mutate_all(~ na_mean(.))
}

# Apply the imputation to healthy and tumor datasets
abundances_healthy_samples_imputed <- impute_missing(abundances_healthy_samples)
abundances_tumor_samples_imputed <- impute_missing(abundances_tumor_samples)



#check if the missing data is gone
vis_miss(abundances_healthy_samples_imputed)

dim(abundances_healthy_samples) #confirmation no data is lost
dim(abundances_healthy_samples_imputed) #confirmation no data is lost

# Combine and recombine with metadata
imputed_patient_data <- bind_cols(abundances_healthy_samples_imputed, abundances_tumor_samples_imputed)
abundances_tsv_imputed <- bind_cols(abundances_metadata, imputed_patient_data)

#filter of abundances imputed tsv
abundances_tsv_imputed_filtered <- abundances_tsv_imputed[vector_filtering_metadata == 0, ]
vis_miss(abundances_tsv_imputed_filtered)

vis_miss(abundances_tsv_imputed)
```

Standardization of data 
```{r}
#define standardization function
standardize <- function(x) {
    if (sd(x) == 0) {
        return(x)
    } else {
        return((x - mean(x)) / sd(x))
    }
}

#copy original dataset
abundances_tsv_imputed_stand <- abundances_tsv_imputed_filtered
metadata_csv_clean_stand <- metadata_csv_clean

# identify numerical columns
numeric_cols_abundances<- sapply(abundances_tsv_imputed_stand, is.numeric)
  # Diameter_of_tumor as numeric
metadata_csv_clean_stand$Diameter_of_tumor <- as.numeric(metadata_csv_clean_stand$Diameter_of_tumor) 
  # delete rows with NA in Diameter_of_tumor
metadata_csv_clean_stand <- metadata_csv_clean_stand[!is.na(metadata_csv_clean_stand$Diameter_of_tumor), ]
numeric_cols_metadata <- sapply(metadata_csv_clean_stand, is.numeric)

#apply standardization function on numerical data
abundances_tsv_imputed_stand[, numeric_cols_abundances] <- lapply(abundances_tsv_imputed_filtered[, numeric_cols_abundances], standardize)
metadata_csv_clean_stand[, numeric_cols_metadata] <- lapply(metadata_csv_clean_stand[, numeric_cols_metadata], standardize)


#check first rows dataset
head(abundances_tsv_imputed_stand)
head(metadata_csv_clean_stand)

```

Data visualization (distributions)
```{r}
#Age in density plot 
metadata_csv_clean_stand %>% 
  ggplot(aes(x=age))+ 
  geom_density(color="darkblue", fill = "darkblue", alpha=0.5)+ 
  theme_classic()+ 
  scale_x_continuous(expand= c(0,0))+ 
  scale_y_continuous(expand= c(0,0)) 
#Age in boxpot to detect outliers  
metadata_csv_clean_stand %>% 
  ggplot(aes(x = "", y = age)) + 
  geom_boxplot(color = "darkblue", fill = "lightblue", alpha = 0.5) + 
  theme_classic() 
#There are two outliers detected 


#Tumor diameter in density plot. Every row with 2 tumors is removed
metadata_csv_clean_stand <- metadata_csv_clean_stand[metadata_csv_clean_stand$Tumor_number == 1, ] 
metadata_csv_clean_stand %>% 
  ggplot(aes(x = Diameter_of_tumor)) +   
  geom_density(color = "darkblue", fill = "darkblue", alpha = 0.5) +   
  theme_classic()  
#Diameter of tumor in boxplot to detect outliers 
metadata_csv_clean_stand %>% 
  ggplot(aes(x = "", y = Diameter_of_tumor)) + 
  geom_boxplot(color = "darkblue", fill = "lightblue", alpha = 0.5) + 
  theme_classic() 
#There are no outliers detected 


#AFP (ng/ml) in density plot 
colnames(metadata_csv_clean_stand)[colnames(metadata_csv_clean_stand) == "AFP_(ng/ml)"] <- "AFPcontinuous" 
metadata_csv_clean_stand %>% 
  ggplot(aes(x=AFPcontinuous))+ 
  geom_density(color="darkblue", fill= "darkblue", alpha=0.5)+ 
  theme_classic() 
#AFPcontinuous in boxplot to detect outliers 
metadata_csv_clean_stand %>% 
  ggplot(aes(x = "", y = AFPcontinuous)) + 
  geom_boxplot(color = "darkblue", fill = "lightblue", alpha = 0.5) + 
  theme_classic() 
#There are 10 outliers detected


#Disease free survival in density plot 
colnames(metadata_csv_clean_stand)[colnames(metadata_csv_clean_stand) == "Disease_free_survival_(m)"] <- "Disease_free_survival" 
metadata_csv_clean_stand %>% 
  ggplot(aes(x=Disease_free_survival))+ 
  geom_density(color="darkblue", fill = "darkblue", alpha=0.5)+ 
  theme_classic()+ 
  scale_x_continuous(expand= c(0,0))+ 
  scale_y_continuous(expand= c(0,0)) 
#Disease free survival in boxplot to detect outliers 
metadata_csv_clean_stand %>% 
  ggplot(aes(x = "", y = Disease_free_survival)) + 
  geom_boxplot(color = "darkblue", fill = "lightblue", alpha = 0.5) + 
  theme_classic() 
#There are no outliers detected 

  

#Total follow-up period in density plot 
colnames(metadata_csv_clean_stand)[colnames(metadata_csv_clean_stand) == "Total_follow_up_period_(m)"] <- "Total_follow_up_period" 
metadata_csv_clean_stand %>% 
  ggplot(aes(x=Total_follow_up_period))+ 
  geom_density(color="darkblue", fill="darkblue", alpha=0.5)+ 
  theme_classic()+ 
  scale_x_continuous(expand= c(0,0))+ 
  scale_y_continuous(expand= c(0,0)) 
#Total follow-up period in boxplot to detect outliers 
metadata_csv_clean_stand %>% 
  ggplot(aes(x = "", y = Total_follow_up_period)) + 
  geom_boxplot(color = "darkblue", fill = "lightblue", alpha = 0.5) + 
  theme_classic() 
#There is one outlier detected 


#Tumor cellularity
metadata_csv_clean_stand %>% 
  ggplot(aes(x =Tumor_cellularity)) + 
  geom_histogram(binwidth = 0.05, color = "darkblue", fill = "darkblue", alpha = 0.5) + 
  theme_classic() 
#Tumor cellularity in boxplot to detect outliers 
metadata_csv_clean_stand %>% 
  ggplot(aes(x = "", y = Tumor_cellularity)) + 
  geom_boxplot(color = "darkblue", fill = "lightblue", alpha = 0.5) + 
  theme_classic() 
#There are three outliers detected 


#Proteomic subtype
metadata_csv_clean_stand %>% 
  ggplot(aes(x = Proteomic_Subtype)) + 
  geom_bar(color = "darkblue", fill = "darkblue", alpha = 0.5) + 
  theme_classic() 

#Proteomic subtype per age 
metadata_csv_clean_stand %>% 
  ggplot(aes(x = age)) + 
  geom_density(color = "darkblue", fill = "darkblue", alpha = 0.5) + 
  theme_classic() + 
  facet_wrap(~ Proteomic_Subtype) 


```

Removing outliers 
```{r} 

#Removing outliers for age 

#Step 1: Calculate IQR and identify outliers 
Q1 <- quantile(metadata_csv_clean_stand$age, 0.25, na.rm = TRUE) 
Q3 <- quantile(metadata_csv_clean_stand$age, 0.75, na.rm = TRUE) 

IQR_value <- Q3 - Q1 

  

#Step 2: Define outlier thresholds 
lower_bound <- Q1 - 1.5 * IQR_value 
upper_bound <- Q3 + 1.5 * IQR_value 

  

#Step 3: Filter the data to remove outliers 
metadata_csv_clean_stand_no_outliers <- metadata_csv_clean_stand %>% 
  filter(age >= lower_bound & age <= upper_bound) 

  

#Step 4: Plot the boxplot without outliers 
metadata_csv_clean_stand_no_outliers %>% 
  ggplot(aes(x = "", y = age)) + 
  geom_boxplot(color = "darkblue", fill = "lightblue", alpha = 0.5) + 
  theme_classic() 

  

#Removing outliers for AFPcontinuous => this is useless because the values for this parameter have a really big range, so if you remove these outliers you will receive new ones 

#Step 1: Calculate IQR and identify outliers 
Q1 <- quantile(metadata_csv_clean_stand$AFPcontinuous, 0.25, na.rm = TRUE) 
Q3 <- quantile(metadata_csv_clean_stand$AFPcontinuous, 0.75, na.rm = TRUE) 
IQR_value <- Q3 - Q1 

  

#Step 2: Define outlier thresholds 
lower_bound <- Q1 - 1.5 * IQR_value 
upper_bound <- Q3 + 1.5 * IQR_value 

  

#Step 3: Filter the data to remove outliers 
metadata_csv_clean_stand_no_outliers <- metadata_csv_clean_stand %>% 
  filter(AFPcontinuous >= lower_bound & AFPcontinuous <= upper_bound) 

  

#Step 4: Plot the boxplot without outliers 
metadata_csv_clean_stand_no_outliers %>% 
  ggplot(aes(x = "", y = AFPcontinuous)) + 
  geom_boxplot(color = "darkblue", fill = "lightblue", alpha = 0.5) + 
  theme_classic() 

  

#Removing outliers for the total follow-up period 

#Step 1: Calculate IQR and identify outliers 
Q1 <- quantile(metadata_csv_clean_stand$Total_follow_up_period, 0.25, na.rm = TRUE) 
Q3 <- quantile(metadata_csv_clean_stand$Total_follow_up_period, 0.75, na.rm = TRUE) 
IQR_value <- Q3 - Q1 

  

#Step 2: Define outlier thresholds 
lower_bound <- Q1 - 1.5 * IQR_value 
upper_bound <- Q3 + 1.5 * IQR_value 

  

#Step 3: Filter the data to remove outliers 
metadata_csv_clean_stand_no_outliers <- metadata_csv_clean_stand %>% 
  filter(Total_follow_up_period >= lower_bound & Total_follow_up_period <= upper_bound) 

  

#Step 4: Plot the boxplot without outliers 
metadata_csv_clean_stand_no_outliers %>% 
  ggplot(aes(x = "", y = Total_follow_up_period)) + 
  geom_boxplot(color = "darkblue", fill = "lightblue", alpha = 0.5) + 
  theme_classic() 

  

#Removing outliers for the tumor cellularity 

#Step 1: Calculate IQR and identify outliers  
Q1 <- quantile(metadata_csv_clean_stand$Tumor_cellularity, 0.25, na.rm = TRUE) 
Q3 <- quantile(metadata_csv_clean_stand$Tumor_cellularity, 0.75, na.rm = TRUE) 
IQR_value <- Q3 - Q1 

  

#Step 2: Define outlier thresholds 
lower_bound <- Q1 - 1.5 * IQR_value 
upper_bound <- Q3 + 1.5 * IQR_value 

  

#Step 3: Filter the data to remove outliers 
metadata_csv_clean_stand_no_outliers <- metadata_csv_clean_stand %>% 
  filter(Tumor_cellularity >= lower_bound & Tumor_cellularity <= upper_bound) 

  

#Step 4: Plot the boxplot without outliers 
metadata_csv_clean_stand_no_outliers %>% 
  ggplot(aes(x = "", y = Tumor_cellularity)) + 
  geom_boxplot(color = "darkblue", fill = "lightblue", alpha = 0.5) + 
  theme_classic() 

``` 



DIFFERENTIAL EXPRESSION ANALYSIS

Principal component analysis enzo
```{r}
#install bioconductor
if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
  BiocManager::install(version = "3.12")}


BiocManager::install("edgeR")
library(edgeR)


library(tibble)
#abundances_test_imputed_stand is latest
# if no standardization needed, use abundances_tsv_imputed_filtered
```

Filter data (tibble conversion to matrix)
```{r}
#can use already NA-filtered and imputed data (confirmed by assistant)
#use abundances_tsv_imputed_filtered
head(abundances_tsv_imputed_filtered) #check datatype: is tibble

#remove the protein_names and symbol, and keep a separate one with them
abundances_DEA_MetaRemoved <- abundances_tsv_imputed_filtered %>% select(-c("Protein.names","Symbol"))
abundances_DEA_MetaMaintained <- abundances_tsv_imputed_filtered %>% select(c("ID","Protein.names","Symbol")) #ID also kept for later matching


abundances_matrix <- as.matrix(column_to_rownames(abundances_DEA_MetaRemoved,"ID"))
class(abundances_matrix) #is a matrix
abundances_matrix[1:5,1:5] #seems to properly maintain ID and sample names

#make a list with every sample from abundances and then type them according to name, make this a table
abundances_sample_type_name <- colnames(abundances_matrix)
abundances_sample_type_table <-  data.frame(Column_name = abundances_sample_type_name)
abundances_sample_type_table #works as intended

#now add P or T based on name
abundances_sample_type_table <- abundances_sample_type_table %>%
  mutate(type = case_when(
    grepl("P", Column_name) ~ "P",
    grepl("T", Column_name) ~ "T",
    TRUE ~ NA_character_
  ))
print(abundances_sample_type_table) #makes a proper table



abundances_dge <- DGEList(counts = abundances_matrix, group = abundances_sample_type_table$type)
dim(abundances_dge) #seems to be properly working
abundances_dge
```


NORMALIZATION NEEDED BECAUSE BATCH EFFECT. agglomeration of several  
filter and impute first, then should normalize, then standardize

normalize
```{r}
#use TMM method from edgeR package
abundances_dge_normalized <- calcNormFactors(abundances_dge, method = "TMM")
head(abundances_dge_normalized$samples) #seems to have changed the norm factors

cpm_matrix <- cpm(abundances_dge_normalized)
plot(abundances_dge_normalized$counts["O95210",],cpm_matrix["O95210",])
plot(abundances_dge$counts["O95210",],cpm_matrix["O95210",])

```


```{r}
#seems to be in order, is a check
#is this really needed? you have the voom function that you can use
log_cpm_matrix <- cpm(abundances_dge_normalized, log=TRUE, prior.count=0.1)
plot(abundances_dge_normalized$counts["P32754",],log_cpm_matrix["P32754",])

```

standardize (use standard scaling because outliers)
ACTUALLY, DON'T STANDARDIZE; messes up any attempt at DEA (introduces negative values), and is also stated by chatGPT to NOT be done because you want the raw biological counts to be maintained
```{r}

# Copy the DGEList
##abundances_dge_normalized_stand <- abundances_dge_normalized

# Extract the counts component for standardization
##counts_matrix <- abundances_dge_normalized_stand$counts

# Identify numeric columns (for a matrix, all columns are numeric, so this is redundant)
##numeric_cols_abundances_dge <- sapply(as.data.frame(counts_matrix), is.numeric)

# Apply standardization only to the counts component
##abundances_dge_normalized_stand$counts <- apply(counts_matrix, 2, standardize)

# Check the result
##head(abundances_dge_normalized_stand$counts)


```


Log transform
```{r}
log_voom_matrix <- voom(abundances_dge_normalized)

```


Dimensionality reduction quality control (MDS or PCA)
ga wss de groeping zien obv groep (dat is hoe ze de groups in paper hebben gevonden)
```{r}
color_type <- as.numeric(as.factor(abundances_sample_type_table$type))
plotMDS(log_voom_matrix, labels = NULL, pch=20, col=color_type)


legend("topright", 
       legend = levels(as.factor(abundances_sample_type_table$type)), 
       col = 1:length(levels(as.factor(abundances_sample_type_table$type))), 
       pch = 20, 
       title = "Sample Types")


```


Differential Expression Analysis 
```{r}
#defining design matrix
design <- model.matrix(~0 + type, data=abundances_sample_type_table) # if you leave out the 0 in this command (try!!!), you will see that you will get a different design matrix (the 0 is used to ask for a model without intercept)
print(design[1:5,])


#defining contrast matrix
contrast.matrix_PT <- makeContrasts(contrast1=typeP-typeT, levels=design)
print(contrast.matrix_PT)

#fitting the expression matrix to linear models
fit <- lmFit(log_voom_matrix, design)
#compute contrast
fit_PT <- contrasts.fit(fit, contrast.matrix_PT)
#Bayes statistic of differential expression
fit_PT <- eBayes(fit_PT)
```
Obtaining DEA results table
```{r}

topprot <- topTable(fit_PT, coef=1, number=Inf) # by putting the argument number=Inf a table with the results for all genes will be generated
dim(topprot)

#top20
top20prot <- topTable(fit_PT, coef=1, number=20) # a table with only top 20 (most differentially expressed) genes will be generated
dim(top20prot)

#significant genes
topsignprot <- topTable(fit_PT, coef=1, number=Inf, p.value=0.05) # you can also make a table with only the significant genes (based on adjusted p-value)
dim(topsignprot) # as we are comparing here very different diseases, there are really a lot differentially expressed genes
head(topprot)
top20prot


```

VOLCANOPLOT
```{r}

volcanoplot(fit_PT, coef=1, highlight = 100, names=rownames(fit_PT))
```

